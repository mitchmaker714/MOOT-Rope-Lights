var currentMode = "boot"; // Initial mode

function switchToMode(newMode) {
  currentMode = newMode;
  if (currentMode === "standby") {
    standbyMode();
  } else if (currentMode === "shutdown") {
    shutdownMode();
  } else if (currentMode === "interactive-passive") {
    interactivePassiveMode();
  } else if (currentMode === "boot") {
    bootMode();
  }
  // Add other modes as needed
}

function standbyMode() {
  var speed = 0.6;
  var pixelsBeforeAfter = 1; // Reduced for slower, more controlled movement
  var offDurationRandomVar = 200;
  var accumMs = 0;
  var blinkDuration = 500; // Duration of the lightning effect
  var offDuration = 0; // Duration of the off time
  var hue = 0; // White color
  var pixel;
  var twinkling = false;
  var pixelCount = 10; // Define the length of the LED strip

  function next() {
    hue = 0; // White color
    pixel = floor(random(pixelCount - 2 * pixelsBeforeAfter) + pixelsBeforeAfter); // Randomly select a pixel index within the range
    blinkDuration = 500; // Duration of the lightning effect in ms
    offDuration = (500 + random(2500)); // Off duration between 0.5 and 3 seconds
    accumMs = 0; // Reset the animation timer
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  export function beforeRender(delta) {
    accumMs += delta;

    var v = triangle(accumMs / blinkDuration); // Fade in and out, 0->1->0

    if (random(pixelCount) < 1 / delta) twinkling = !twinkling; // Chaotic flip-flop 0/1
    if (v > 0.6) v -= twinkling * 0.5; // If in the top 40% of intensities, twinkle
    v *= v; // Typical gamma-correction

    if (accumMs > blinkDuration) v = 0; // Dark for offDuration
    if (accumMs > blinkDuration + offDuration) next(); // Zero's accumMs
  }

  export function render(index) {
    var isInRange = index >= pixel - pixelsBeforeAfter && index <= pixel + pixelsBeforeAfter;

    // Set color based on whether the index is in the range of pixels before and after
    if (isInRange) {
      // Calculate the distance from the center pixel
      var distance = abs(index - pixel);
      // Interpolate v between consecutive pixels
      var interpolatedV = lerp(0, v, 1 - distance / pixelsBeforeAfter);

      hsv(hue, 0, interpolatedV * 2); // White color, saturation 0
    } else {
      hsv(0, 0, 0); // All other pixels off
    }
  }

  // Initialize the standby mode
  next();
}

function interactivePassiveMode() {
  export function beforeRender(delta) {
    t1 = time(3.3 / 65.536) * PI2 // Sawtooth 0 to 2*PI every 3.3 seconds
    t2 = time(6.0 / 65.536) * PI2 // Sawtooth 0 to 2*PI every 6 seconds
    z = 1 + wave(time(13 / 65.536)) * 5 // Sine wave, min = 1, max = 6
  }

  export function render(index) {
    pct = index / pixelCount  // Transform index..pixelCount to 0..1

    // Since we are now in 1D, we use `pct` as our x coordinate and set y to 0
    x = 8 * pct
    y = 0

    h = (1 + sin(x * z + t1) + cos(y * z + t2)) * 0.5
    
    v = h
    
    v = v * v * v / 2 

    hsv(h, 1, v)
  }
}

// Initialize the first mode
if (currentMode === "boot") {
  bootMode();
}
